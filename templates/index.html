<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Mapbox Application</title>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.12.0/mapbox-gl.css" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.12.0/mapbox-gl.js"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
  <style>
    body {
      margin: 0;
      padding: 0;
    }

    #map-container {
      width: 100vw;
      height: 100vh;
    }

    .map-overlay {
      font:
        12px/20px 'Helvetica Neue',
        Arial,
        Helvetica,
        sans-serif;
      position: absolute;
      width: 350px;
      top: 0;
      left: 0;
      padding: 10px;
    }

    .map-overlay .map-overlay-inner {
      background-color: #fff;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      border-radius: 3px;
      padding: 10px;
      margin-bottom: 10px;
    }

    .map-overlay-inner fieldset {
      display: flex;
      justify-content: space-between;
      border: none;
    }

    .map-overlay-inner label {
      font-weight: bold;
      margin-right: 10px;
    }

    .map-overlay-inner .select-fieldset {
      display: block;
    }

    .map-overlay-inner .select-fieldset label {
      display: block;
      margin-bottom: 5px;
    }

    .map-overlay-inner .select-fieldset select {
      width: 100%;
    }
  </style>
</head>

<body>
  <div id="map-container"></div>
  <div class="map-overlay top">
    <div class="map-overlay-inner">
     <h1>Yale Shuttle Route Finder</h1>
      <p>Click to select start and end points.</p>
        <fieldset class="select-fieldset">
            <label id="coord1">Start Coord:</label>
            <label id="coord2">End Coord:</label>
        </fieldset>
    </div>
  </div>


  <script>
    mapboxgl.accessToken = 'pk.eyJ1Ijoic29seWNhIiwiYSI6ImNpejhqZmlmNjAwMDUycW82N3g2dG05ZHYifQ.CKn9Ww3bjhirdny-PIZqdg';
    const map = new mapboxgl.Map({
      container: 'map-container',
      style: 'mapbox://styles/mapbox/streets-v11',
      center: [-72.923995, 41.309798],
      zoom: 12
    });

    let markers = {};
    let stops_arr = {};
    let coordtoggle = true;
    var startCoordList = null;
    var endCoordList = null;

    const colorDict = {
      '1': '#4472C4',
      '2': '#ED7D31',
      '3': '#FF0000',
      '8': '#DB1AD2',
      '9': '#70AD46',
      '10': '#6F30A1',
      '11': '#7E6001',
      '12': '#F6BE00'
    };

    const routesNames = {
      '1': 'Blue',
      '2': 'Orange',
      '3': 'Red',
      '8': 'Pink',
      '9': 'Green',
      '10': 'Purple',
      '11': 'Brown',
      '12': 'Yellow'
    };

    function getMarkerColor(route) {
      return colorDict[route] || '#000000'; // Assign default color if not found in the dictionary
    }

    function updateMarkers(data) {
      data.forEach(row => {
        const { id, name, lat, lon, heading, route, lastStop, lastUpdate } = row;
        const key = `${route}-${id}`;
        if (markers[key]) {
          // Update the position of the existing marker
          markers[key].setLngLat([lon, lat]);
        } else {
          // Create a new marker
          const color = getMarkerColor(route);
          markers[key] = new mapboxgl.Marker({
            color: color
          })
            .setLngLat([lon, lat])
            .addTo(map);
        }

        markers[key].setPopup(
          new mapboxgl.Popup()
            .setHTML(`
                <h3>${routesNames[route]} Shuttle</h3>
                <p>Name: ${name}</p>
                <p>Heading: ${heading}Â°</p>
                <p>Last stop: ${lastStop}</p>
                <p>Last update: ${new Date(lastUpdate * 1000).toLocaleString()}</p>
              `)
        );
      });
    }

    function updateStops(stops) {
      stops.forEach((row, index) => {
        const { id, name, lat, lon } = row;
        const key = `${id}`;
        const dotElement = document.createElement('div');
        dotElement.className = 'dot-marker';
    
        if (stops_arr[key]) {
          stops_arr[key].setLngLat([lon, lat]);
        } else {
          const popup = new mapboxgl.Popup({
            closeButton: false,
            closeOnClick: false
          }).setHTML(`
            <p>Name: ${name}</p>
          `);
    
          stops_arr[key] = new mapboxgl.Marker({
            element: dotElement,
          })
          .setLngLat([lon, lat])
          .setPopup(popup)
          .addTo(map);
    
          // Set a higher z-index for the stop marker
          stops_arr[key].getElement().style.zIndex = 1000;
    
          stops_arr[key].getElement().addEventListener('mouseenter', () => {
            stops_arr[key].togglePopup();
          });
    
          stops_arr[key].getElement().addEventListener('mouseleave', () => {
            stops_arr[key].togglePopup();
          });
        }
      });
    }
  
    function fetchAndUpdateData() {
      fetch('http://localhost:3000/data')
        .then(response => response.json())
        .then(data => {
          updateMarkers(data);
        })
        .catch(error => {
          console.error('Error fetching data:', error);
        });
    }

    function fetchAndUpdateStops() {
      console.log("fetchAndUpdateStops called");
      fetch('http://localhost:3000/stops')
        .then(response => response.json())
        .then(data => {
          console.log(data);
          updateStops(data);
        })
        .catch(error => {
          console.error('Error fetching data:', error);
        });
    }

    /*function sendCoordinates(start, end) {
      if (startCoordList != null && endCoordList != null) {
        fetch('/receive-coordinates', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ start: startCoordList, end: endCoordList })
        })
          .then(response => {
            if (response.ok) {
              console.log('Coordinates sent successfully!');
            } else {
              console.error('Failed to send coordinates.');
            }
          })
          .catch(error => {
            console.error('Error:', error);
          });
      } else {
        console.error("Error: No valid pair of coordinates available to send.")
      }
    }*/

    function findShortestRoute(startCoord, endCoord) {
      fetch('/find-shortest-route', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ start: 34, end: 72 })
      })
        .then(response => {
          if (response.ok) {
            return response.json(); // Return the GeoJSON response
          } else {
            throw new Error('Failed to find shortest route.');
          }
        })
        .then(routeData => {
          console.log('Route data:', routeData);
    
          // Split the routeData into segments based on the route ID
          const segments = [];
          let currentSegment = [routeData[0]];
          let currentRouteId = routeData[0][1];
    
          for (let i = 1; i < routeData.length; i++) {
            if (routeData[i][1] === currentRouteId) {
              currentSegment.push(routeData[i]);
            } else {
              segments.push({ routeId: currentRouteId, coordinates: currentSegment });
              currentSegment = [routeData[i]];
              currentRouteId = routeData[i][1];
            }
          }
          segments.push({ routeId: currentRouteId, coordinates: currentSegment });
    
          // Process each segment separately
          const segmentPromises = segments.map(segment => {
            const coordinates = segment.coordinates.map(coord => coord[0]);
            console.log('Segment coordinates:', coordinates);
            const coords = coordinates.join(';');
            const url = `https://api.mapbox.com/directions/v5/mapbox/driving/${coords}?access_token=${mapboxgl.accessToken}&geometries=geojson`;
            console.log('URL:', url);
            return fetch(url).then(response => response.json()).then(data => ({
              routeId: segment.routeId,
              geometry: data.routes[0].geometry
            }));
          });
    
          return Promise.all(segmentPromises);
        })
        .then(dataArray => {
          // Remove the existing 'route' source and layer if they exist
          if (map.getSource('route')) {
            map.removeLayer('route');
            map.removeSource('route');
          }
    
          // Add a new source and layer for each segment with different colors
          dataArray.forEach((data, index) => {
            const { routeId, geometry } = data;
            const color = getMarkerColor(routeId.toString());
    
            map.addSource(`route-${index}`, {
              type: 'geojson',
              data: {
                type: 'Feature',
                geometry: geometry
              }
            });
    
            map.addLayer({
              id: `route-${index}`,
              type: 'line',
              source: `route-${index}`,
              paint: {
                'line-color': color,
                'line-width': 5,
                'line-opacity': 0.75
              }
            });
          });

          Object.values(stops_arr).forEach(marker => {
            marker.addTo(map);
          });
        })
        
        .catch(error => {
          console.error('Error:', error);
        });
    }

    //onClick, update the end coordinates, and pass them to the server to find the shortest route. Also checks for user location.
    map.on('click', (e) => {
      if (startCoordList == null) {
        document.getElementById('coord1').innerHTML = "No user location";
        document.getElementById('coord2').innerHTML = "Please enable location with the button the top right of the map.";
      } else {
        endCoordList = [e.lngLat.lng, e.lngLat.lat];
        document.getElementById('coord2').innerHTML = "End Coord: " + endCoordList.toString();

        findShortestRoute(startCoordList, endCoordList);
      }
    });

    /*
      For geolocation to work, the browser needs to allow the local server access to the location. Because the connection isn't secure,
      it is blocked by default for security reasons. You can disable it like so:
      https://stackoverflow.com/questions/57450093/browser-says-camera-blocked-to-protect-your-privacy
      (This says for the camera, but it applies to all browser permissions.)
      After that you can click the button on the top right to give the map your location.
    */
    // START Geolocation
    const geolocate = new mapboxgl.GeolocateControl({
      positionOptions: {
        enableHighAccuracy: true
      },
      trackUserLocation: true
    });

    // Move the geolocate control to the bottom left
    map.addControl(geolocate, 'bottom-left');

    geolocate.on('geolocate', (e) => {
      var lon = e.coords.longitude;
      var lat = e.coords.latitude;
      startCoordList = [lon, lat];
      document.getElementById('coord1').innerHTML = "Start Coord: " + startCoordList.toString();
      document.getElementById('coord2').innerHTML = "End Coord: ";
      console.log('A geolocate event has occurred.');
    });
    // END Geolocation

    fetchAndUpdateData();

    console.log("Fetching stops");
    fetchAndUpdateStops();
    setInterval(fetchAndUpdateData, 10000); // Update every 10 seconds
  </script>
</body>

</html>
